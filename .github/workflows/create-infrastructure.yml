name: Create Infrastructure and Deploy Application

on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  TF_STATE_BUCKET_PREFIX: "hrgoat-tfstate-do-not-delete"
  TF_STATE_KEY: "terraform/state/prod/terraform.tfstate"
  PROJECT_NAME: "hrgoat"
  DB_PASSWORD: "hrportaladmin123"

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    outputs:
      app_instance_id: ${{ steps.terraform_outputs.outputs.app_instance_id }}
      rds_endpoint: ${{ steps.terraform_outputs.outputs.rds_endpoint }}
      ecr_repository_url: ${{ steps.terraform_outputs.outputs.ecr_repository_url }}
      tf_state_bucket: ${{ steps.create_bucket.outputs.bucket_name }}
      alb_dns_name: ${{ steps.terraform_outputs.outputs.alb_dns_name }}
      app_alb_url: ${{ steps.terraform_outputs.outputs.app_alb_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: "us-east-1"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.0.0

    - name: Create unique S3 bucket name for Terraform state
      id: create_bucket
      run: |
        # Generate unique bucket name with epoch timestamp
        TIMESTAMP=$(date +%s)
        BUCKET_NAME="${{ env.TF_STATE_BUCKET_PREFIX }}-${TIMESTAMP}"
        echo "bucket_name=${BUCKET_NAME}" >> $GITHUB_OUTPUT
        echo "Using bucket name: ${BUCKET_NAME}"

    - name: Create S3 bucket for Terraform state if it doesn't exist
      run: |
        BUCKET_NAME="${{ steps.create_bucket.outputs.bucket_name }}"
        
        aws s3api head-bucket --bucket ${BUCKET_NAME} 2>/dev/null || \
        aws s3api create-bucket --bucket ${BUCKET_NAME} --region ${{ env.AWS_REGION }}
        
        # Enable versioning
        aws s3api put-bucket-versioning --bucket ${BUCKET_NAME} --versioning-configuration Status=Enabled
        
        # Store bucket name in a file that will be stored in S3 for reference by destroy workflow
        echo "BUCKET_NAME=${BUCKET_NAME}" > bucket-name.txt
        aws s3 cp bucket-name.txt s3://${BUCKET_NAME}/bucket-name.txt

    - name: Terraform Init
      run: |
        cd terraform
        terraform init \
          -backend-config="bucket=${{ steps.create_bucket.outputs.bucket_name }}" \
          -backend-config="key=${{ env.TF_STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}"

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan -var="project_name=${{ env.PROJECT_NAME }}" -var="db_password=${{ env.DB_PASSWORD }}" -out=tfplan

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve tfplan

    - name: Export Terraform Outputs
      id: terraform_outputs
      run: |
        cd terraform
        
        # Extract outputs from Terraform
        RAW_APP_INSTANCE_ID=$(terraform output -raw app_instance_id 2>/dev/null || echo "")
        RAW_RDS_ENDPOINT=$(terraform output -raw rds_endpoint 2>/dev/null || echo "")
        RAW_ECR_REPOSITORY_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
        RAW_ALB_DNS_NAME=$(terraform output -raw alb_dns_name 2>/dev/null || echo "")
        RAW_APP_ALB_URL=$(terraform output -raw app_alb_url 2>/dev/null || echo "")
        
        # Print raw outputs for debugging
        echo "Raw outputs before cleaning:"
        echo "RAW_APP_INSTANCE_ID: $RAW_APP_INSTANCE_ID"
        echo "RAW_RDS_ENDPOINT: $RAW_RDS_ENDPOINT"
        echo "RAW_ECR_REPOSITORY_URL: $RAW_ECR_REPOSITORY_URL"
        echo "RAW_ALB_DNS_NAME: $RAW_ALB_DNS_NAME"
        echo "RAW_APP_ALB_URL: $RAW_APP_ALB_URL"
        
        # Extract the clean values using cut (more reliable than sed in this case)
        # This cuts the string at the first occurrence of ::debug:: and keeps only what's before it
        APP_INSTANCE_ID=$(echo "$RAW_APP_INSTANCE_ID" | cut -d ':' -f 1)
        RDS_ENDPOINT=$(echo "$RAW_RDS_ENDPOINT" | cut -d ':' -f 1,2,3)
        ECR_REPOSITORY_URL=$(echo "$RAW_ECR_REPOSITORY_URL" | grep -o '^[^:]*\.dkr\.ecr\.[^:]*\.amazonaws\.com/[^:]*')
        ALB_DNS_NAME=$(echo "$RAW_ALB_DNS_NAME" | grep -o '^[^:]*\.elb\.amazonaws\.com')
        APP_ALB_URL=$(echo "$RAW_APP_ALB_URL" | grep -o '^http://[^:]*\.elb\.amazonaws\.com')
        
        # Print cleaned outputs for verification
        echo "Extracted outputs after cleaning:"
        echo "APP_INSTANCE_ID: $APP_INSTANCE_ID"
        echo "RDS_ENDPOINT: $RDS_ENDPOINT"
        echo "ECR_REPOSITORY_URL: $ECR_REPOSITORY_URL"
        echo "ALB_DNS_NAME: $ALB_DNS_NAME"
        echo "APP_ALB_URL: $APP_ALB_URL"
        
        # Export to GitHub output variables with the correct format
        echo "app_instance_id=$APP_INSTANCE_ID" >> "$GITHUB_OUTPUT"
        echo "rds_endpoint=$RDS_ENDPOINT" >> "$GITHUB_OUTPUT"
        echo "ecr_repository_url=$ECR_REPOSITORY_URL" >> "$GITHUB_OUTPUT"
        echo "alb_dns_name=$ALB_DNS_NAME" >> "$GITHUB_OUTPUT"
        echo "app_alb_url=$APP_ALB_URL" >> "$GITHUB_OUTPUT"

  build-and-deploy:
    name: 'Build and Deploy Application'
    needs: terraform
    runs-on: ubuntu-latest
    if: ${{ needs.terraform.outputs.app_instance_id != '' && needs.terraform.outputs.ecr_repository_url != '' }}

    env:
      APP_INSTANCE_ID: ${{ needs.terraform.outputs.app_instance_id }}
      RDS_HOST: ${{ needs.terraform.outputs.rds_endpoint }}
      ECR_REPOSITORY: ${{ needs.terraform.outputs.ecr_repository_url }}
      RDS_USER: admin
      RDS_PASSWORD: hrportaladmin123
      RDS_DATABASE: hrportal
      TF_STATE_BUCKET: ${{ needs.terraform.outputs.tf_state_bucket }}
      ALB_DNS_NAME: ${{ needs.terraform.outputs.alb_dns_name }}
      APP_ALB_URL: ${{ needs.terraform.outputs.app_alb_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # Build a docker container and push it to ECR
        docker build -t ${{ env.ECR_REPOSITORY }}:${{ github.sha }} .
        docker push ${{ env.ECR_REPOSITORY }}:${{ github.sha }}
        docker tag ${{ env.ECR_REPOSITORY }}:${{ github.sha }} ${{ env.ECR_REPOSITORY }}:latest
        docker push ${{ env.ECR_REPOSITORY }}:latest
        echo "image=${{ env.ECR_REPOSITORY }}:${{ github.sha }}" >> $GITHUB_OUTPUT

    - name: Deploy to EC2 via SSM
      run: |
        # Wait for EC2 instance to be ready
        echo "Waiting for EC2 instance to be ready..."
        aws ec2 wait instance-status-ok --instance-ids ${{ env.APP_INSTANCE_ID }}
        
        # Deploy using SSM
        aws ssm send-command \
          --instance-ids ${{ env.APP_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands="
            # Stop and remove any existing container
            docker stop hrportal || true
            docker rm hrportal || true
            
            # Login to ECR
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $(echo '${{ env.ECR_REPOSITORY }}' | cut -d/ -f1)
            
            # Pull the latest image
            docker pull ${{ steps.build-image.outputs.image }}
            
            # Run the container with environment variables
            docker run -d \
              --name hrportal \
              -p 3000:3000 \
              -e DB_HOST='$(echo '${{ env.RDS_HOST }}' | cut -d: -f1)' \
              -e DB_USER='${{ env.RDS_USER }}' \
              -e DB_PASSWORD='${{ env.RDS_PASSWORD }}' \
              -e DB_NAME='${{ env.RDS_DATABASE }}' \
              ${{ steps.build-image.outputs.image }}
            
            # Check if container is running
            docker ps | grep hrportal
          " \
          --output text

    - name: Output Deployment Info
      run: |
        echo "Application deployed successfully!"
        
        if [ -n "${{ env.APP_ALB_URL }}" ]; then
          echo "Application Load Balancer URL: ${{ env.APP_ALB_URL }}"
        else
          echo "Application Load Balancer URL: Not available"
        fi
        
        if [ -n "${{ env.ALB_DNS_NAME }}" ]; then
          echo "Application Load Balancer DNS: ${{ env.ALB_DNS_NAME }}"
        else
          echo "Application Load Balancer DNS: Not available"
        fi
        
        EC2_IP=$(aws ec2 describe-instances --instance-ids ${{ env.APP_INSTANCE_ID }} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null)
        if [ -n "$EC2_IP" ] && [ "$EC2_IP" != "None" ]; then
          echo "Direct EC2 URL: http://$EC2_IP:3000"
        else
          echo "Direct EC2 URL: Not available"
        fi
        
        JENKINS_IP=$(aws ec2 describe-instances --filters 'Name=tag:Name,Values=${{ env.PROJECT_NAME }}-jenkins-instance' --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null)
        if [ -n "$JENKINS_IP" ] && [ "$JENKINS_IP" != "None" ]; then
          echo "Jenkins server should be accessible at: http://$JENKINS_IP:8080"
        else
          echo "Jenkins server: Not available or still starting up"
        fi
        
        echo "Terraform state is stored in S3 bucket: ${{ env.TF_STATE_BUCKET }}"
        echo "To destroy this infrastructure, use the Destroy Infrastructure workflow with this bucket name." 