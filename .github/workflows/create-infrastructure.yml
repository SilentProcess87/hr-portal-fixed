name: Create Infrastructure and Deploy Application

on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  TF_STATE_BUCKET_PREFIX: "hrgoat-tfstate-do-not-delete"
  TF_STATE_KEY: "terraform/state/prod/terraform.tfstate"
  PROJECT_NAME: "hrgoat"
  DB_PASSWORD: "hrportaladmin123"

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    outputs:
      app_instance_id: ${{ steps.terraform_outputs.outputs.app_instance_id }}
      rds_endpoint: ${{ steps.terraform_outputs.outputs.rds_endpoint }}
      ecr_repository_name: ${{ steps.terraform_outputs.outputs.ecr_repository_name }}
      tf_state_bucket: ${{ steps.create_bucket.outputs.bucket_name }}
      alb_dns_name: ${{ steps.terraform_outputs.outputs.alb_dns_name }}
      app_alb_url: ${{ steps.terraform_outputs.outputs.app_alb_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: "us-east-1"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.0.0

    - name: Create unique S3 bucket name for Terraform state
      id: create_bucket
      run: |
        # Generate unique bucket name with epoch timestamp
        TIMESTAMP=$(date +%s)
        BUCKET_NAME="${{ env.TF_STATE_BUCKET_PREFIX }}-${TIMESTAMP}"
        echo "bucket_name=${BUCKET_NAME}" >> $GITHUB_OUTPUT
        echo "Using bucket name: ${BUCKET_NAME}"

    - name: Create S3 bucket for Terraform state if it doesn't exist
      run: |
        BUCKET_NAME="${{ steps.create_bucket.outputs.bucket_name }}"
        
        aws s3api head-bucket --bucket ${BUCKET_NAME} 2>/dev/null || \
        aws s3api create-bucket --bucket ${BUCKET_NAME} --region ${{ env.AWS_REGION }}
        
        # Enable versioning
        aws s3api put-bucket-versioning --bucket ${BUCKET_NAME} --versioning-configuration Status=Enabled
        
        # Store bucket name in a file that will be stored in S3 for reference by destroy workflow
        echo "BUCKET_NAME=${BUCKET_NAME}" > bucket-name.txt
        aws s3 cp bucket-name.txt s3://${BUCKET_NAME}/bucket-name.txt

    - name: Terraform Init
      run: |
        cd terraform
        terraform init \
          -backend-config="bucket=${{ steps.create_bucket.outputs.bucket_name }}" \
          -backend-config="key=${{ env.TF_STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}"

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan -var="project_name=${{ env.PROJECT_NAME }}" -var="db_password=${{ env.DB_PASSWORD }}" -out=tfplan

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve tfplan

    - name: Export Terraform Outputs
      id: terraform_outputs
      run: |
        cd terraform
        
        # Display all available outputs for debugging
        echo "All Terraform outputs:"
        terraform output
        
        # Extract outputs from Terraform and save to files
        terraform output -raw app_instance_id > app_instance_id.txt 2>/dev/null || echo "i-dummyinstance" > app_instance_id.txt
        terraform output -raw rds_endpoint > rds_endpoint.txt 2>/dev/null || echo "dummy-db.us-east-1.rds.amazonaws.com:3306" > rds_endpoint.txt
        terraform output -raw ecr_repository_url > ecr_repository_url.txt 2>/dev/null || echo "" > ecr_repository_url.txt
        terraform output -raw alb_dns_name > alb_dns_name.txt 2>/dev/null || echo "dummy-alb.us-east-1.elb.amazonaws.com" > alb_dns_name.txt
        terraform output -raw app_alb_url > app_alb_url.txt 2>/dev/null || echo "http://dummy-alb.us-east-1.elb.amazonaws.com" > app_alb_url.txt
        
        # Show content of each file for debugging
        echo "Contents of app_instance_id.txt:"
        cat app_instance_id.txt
        echo "Contents of rds_endpoint.txt:"
        cat rds_endpoint.txt
        
        # Process the files to extract the actual values (skipping command lines and debug info)
        APP_INSTANCE_ID=$(grep -v '^\[command\]' app_instance_id.txt | tail -1 | sed 's/::debug::.*$//')
        RDS_ENDPOINT=$(grep -v '^\[command\]' rds_endpoint.txt | tail -1 | sed 's/::debug::.*$//')
        ECR_REPOSITORY_URL=$(grep -v '^\[command\]' ecr_repository_url.txt | tail -1 | sed 's/::debug::.*$//')
        ALB_DNS_NAME=$(grep -v '^\[command\]' alb_dns_name.txt | tail -1 | sed 's/::debug::.*$//')
        APP_ALB_URL=$(grep -v '^\[command\]' app_alb_url.txt | tail -1 | sed 's/::debug::.*$//')
        
        # Instead of trying to extract the repository name from the masked URL, use the known naming convention
        # In Terraform, the repository is created as "${var.project_name}-app-repository"
        ECR_REPOSITORY_NAME="${{ env.PROJECT_NAME }}-app-repository"
        echo "ECR_REPOSITORY_NAME: $ECR_REPOSITORY_NAME"
        
        echo "ALB_DNS_NAME: $ALB_DNS_NAME"
        echo "APP_ALB_URL: $APP_ALB_URL"
        
        # Export outputs in GitHub Actions format
        # Make sure to properly format the outputs according to GitHub Actions requirements
        {
          echo "app_instance_id=$APP_INSTANCE_ID"
        } >> "$GITHUB_OUTPUT"
        
        {
          echo "rds_endpoint=$RDS_ENDPOINT"
        } >> "$GITHUB_OUTPUT"
        
        {
          echo "ecr_repository_name=$ECR_REPOSITORY_NAME"
        } >> "$GITHUB_OUTPUT"
        
        {
          echo "alb_dns_name=$ALB_DNS_NAME"
        } >> "$GITHUB_OUTPUT"
        
        {
          echo "app_alb_url=$APP_ALB_URL"
        } >> "$GITHUB_OUTPUT"

  build-and-deploy:
    name: 'Build and Deploy Application'
    needs: terraform
    runs-on: ubuntu-latest
    # Always run this job when terraform completes, as the outputs issue should be fixed now

    env:
      APP_INSTANCE_ID: ${{ needs.terraform.outputs.app_instance_id }}
      RDS_HOST: ${{ needs.terraform.outputs.rds_endpoint }}
      ECR_REPOSITORY_NAME: ${{ needs.terraform.outputs.ecr_repository_name }}
      RDS_USER: admin
      RDS_PASSWORD: hrportaladmin123
      RDS_DATABASE: hrportal
      TF_STATE_BUCKET: ${{ needs.terraform.outputs.tf_state_bucket }}
      ALB_DNS_NAME: ${{ needs.terraform.outputs.alb_dns_name }}
      APP_ALB_URL: ${{ needs.terraform.outputs.app_alb_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Debug environment variables
      run: |
        echo "ECR Registry: ${{ steps.login-ecr.outputs.registry }}"
        echo "ECR Repository Name: ${{ env.ECR_REPOSITORY_NAME }}"
        if [ -z "${{ env.ECR_REPOSITORY_NAME }}" ]; then
          echo "::error::ECR_REPOSITORY_NAME is empty!"
          exit 1
        fi

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # Construct the full ECR repository URL using the registry from login step
        FULL_ECR_REPOSITORY="${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_NAME }}"
        echo "Full ECR Repository URL: ${FULL_ECR_REPOSITORY}"
        
        # Build a docker container and push it to ECR
        docker build -t ${FULL_ECR_REPOSITORY}:${{ github.sha }} .
        docker push ${FULL_ECR_REPOSITORY}:${{ github.sha }}
        docker tag ${FULL_ECR_REPOSITORY}:${{ github.sha }} ${FULL_ECR_REPOSITORY}:latest
        docker push ${FULL_ECR_REPOSITORY}:latest
        echo "image=${FULL_ECR_REPOSITORY}:${{ github.sha }}" >> $GITHUB_OUTPUT

    - name: Deploy to EC2 via SSM
      run: |
        # Verify we have the required values
        echo "Checking essential parameters:"
        echo "APP_INSTANCE_ID: ${{ env.APP_INSTANCE_ID }}"
        echo "RDS_HOST: ${{ env.RDS_HOST }}"
        
        # Exit if essential parameters are missing
        if [ -z "${{ env.APP_INSTANCE_ID }}" ]; then
          echo "::error::APP_INSTANCE_ID is empty! Cannot continue deployment."
          exit 1
        fi
        
        # Extract RDS hostname from endpoint if available
        DB_HOST=""
        if [ -n "${{ env.RDS_HOST }}" ]; then
          DB_HOST=$(echo "${{ env.RDS_HOST }}" | cut -d: -f1)
        fi
        
        # Wait for EC2 instance to be ready
        echo "Waiting for EC2 instance to be ready..."
        aws ec2 wait instance-status-ok --instance-ids ${{ env.APP_INSTANCE_ID }}
        
        # Deploy using SSM with multiple separate commands
        aws ssm send-command \
          --instance-ids ${{ env.APP_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands=["docker stop hrportal || true",
                                "docker rm hrportal || true",
                                "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}",
                                "docker pull ${{ steps.build-image.outputs.image }}",
                                "docker run -d --name hrportal -p 3000:3000 -e DB_HOST=\"$DB_HOST\" -e DB_USER=\"${{ env.RDS_USER }}\" -e DB_PASSWORD=\"${{ env.RDS_PASSWORD }}\" -e DB_NAME=\"${{ env.RDS_DATABASE }}\" ${{ steps.build-image.outputs.image }}",
                                "docker ps | grep hrportal"] \
          --output text

    - name: Output Deployment Info
      run: |
        echo "Application deployed successfully!"
        
        if [ -n "${{ env.APP_ALB_URL }}" ]; then
          echo "Application Load Balancer URL: ${{ env.APP_ALB_URL }}"
        else
          echo "Application Load Balancer URL: Not available"
        fi
        
        if [ -n "${{ env.ALB_DNS_NAME }}" ]; then
          echo "Application Load Balancer DNS: ${{ env.ALB_DNS_NAME }}"
        else
          echo "Application Load Balancer DNS: Not available"
        fi
        
        EC2_IP=$(aws ec2 describe-instances --instance-ids ${{ env.APP_INSTANCE_ID }} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null)
        if [ -n "$EC2_IP" ] && [ "$EC2_IP" != "None" ]; then
          echo "Direct EC2 URL: http://$EC2_IP:3000"
        else
          echo "Direct EC2 URL: Not available"
        fi
        
        JENKINS_IP=$(aws ec2 describe-instances --filters 'Name=tag:Name,Values=${{ env.PROJECT_NAME }}-jenkins-instance' --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null)
        if [ -n "$JENKINS_IP" ] && [ "$JENKINS_IP" != "None" ]; then
          echo "Jenkins server should be accessible at: http://$JENKINS_IP:8080"
        else
          echo "Jenkins server: Not available or still starting up"
        fi
        
        echo "Terraform state is stored in S3 bucket: ${{ env.TF_STATE_BUCKET }}"
        echo "To destroy this infrastructure, use the Destroy Infrastructure workflow with this bucket name." 