name: Create Infrastructure and Deploy Application

on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  TF_STATE_BUCKET_PREFIX: "hrgoat-tfstate-do-not-delete"
  TF_STATE_KEY: "terraform/state/prod/terraform.tfstate"
  PROJECT_NAME: "hrgoat"
  DB_PASSWORD: "hrportaladmin123"

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    outputs:
      app_instance_id: ${{ steps.terraform_outputs.outputs.app_instance_id }}
      rds_endpoint: ${{ steps.terraform_outputs.outputs.rds_endpoint }}
      ecr_repository_name: ${{ steps.terraform_outputs.outputs.ecr_repository_name }}
      tf_state_bucket: ${{ steps.create_bucket.outputs.bucket_name }}
      alb_dns_name: ${{ steps.terraform_outputs.outputs.alb_dns_name }}
      app_alb_url: ${{ steps.terraform_outputs.outputs.app_alb_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: "us-east-1"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.0.0

    - name: Create unique S3 bucket name for Terraform state
      id: create_bucket
      run: |
        # Generate unique bucket name with epoch timestamp
        TIMESTAMP=$(date +%s)
        BUCKET_NAME="${{ env.TF_STATE_BUCKET_PREFIX }}-${TIMESTAMP}"
        echo "bucket_name=${BUCKET_NAME}" >> $GITHUB_OUTPUT
        echo "Using bucket name: ${BUCKET_NAME}"

    - name: Create S3 bucket for Terraform state if it doesn't exist
      run: |
        BUCKET_NAME="${{ steps.create_bucket.outputs.bucket_name }}"
        
        aws s3api head-bucket --bucket ${BUCKET_NAME} 2>/dev/null || \
        aws s3api create-bucket --bucket ${BUCKET_NAME} --region ${{ env.AWS_REGION }}
        
        # Enable versioning
        aws s3api put-bucket-versioning --bucket ${BUCKET_NAME} --versioning-configuration Status=Enabled
        
        # Store bucket name in a file that will be stored in S3 for reference by destroy workflow
        echo "BUCKET_NAME=${BUCKET_NAME}" > bucket-name.txt
        aws s3 cp bucket-name.txt s3://${BUCKET_NAME}/bucket-name.txt

    - name: Terraform Init
      run: |
        cd terraform
        terraform init \
          -backend-config="bucket=${{ steps.create_bucket.outputs.bucket_name }}" \
          -backend-config="key=${{ env.TF_STATE_KEY }}" \
          -backend-config="region=${{ env.AWS_REGION }}"

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan -var="project_name=${{ env.PROJECT_NAME }}" -var="db_password=${{ env.DB_PASSWORD }}" -out=tfplan

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve tfplan

    - name: Export Terraform Outputs
      id: terraform_outputs
      run: |
        cd terraform
        
        # Display all available outputs for debugging
        echo "All Terraform outputs:"
        terraform output || echo "No outputs found"
        
        # Check if core resources were created by querying AWS directly
        echo "Checking for resources created by Terraform..."
        
        # 1. Get EC2 instance by tag
        APP_INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=${{ env.PROJECT_NAME }}-app-instance" --query "Reservations[0].Instances[0].InstanceId" --output text)
        if [ "$APP_INSTANCE_ID" == "None" ] || [ -z "$APP_INSTANCE_ID" ]; then
          echo "Warning: Could not find app instance with tag Name=${{ env.PROJECT_NAME }}-app-instance"
          # Try to fallback to any instance with our project tag
          APP_INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag-key,Values=Project" "Name=tag-value,Values=${{ env.PROJECT_NAME }}" --query "Reservations[0].Instances[0].InstanceId" --output text)
        fi
        echo "Found EC2 instance ID: $APP_INSTANCE_ID"
        
        # 2. Get RDS instance by tag/identifier
        RDS_ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier "${{ env.PROJECT_NAME }}-db" --query "DBInstances[0].Endpoint.Address" --output text 2>/dev/null)
        if [ "$RDS_ENDPOINT" == "None" ] || [ -z "$RDS_ENDPOINT" ]; then
          echo "Warning: Could not find RDS instance with identifier ${{ env.PROJECT_NAME }}-db"
          # Look for any instance with similar name
          RDS_ENDPOINT=$(aws rds describe-db-instances --query "DBInstances[?starts_with(DBInstanceIdentifier, '${{ env.PROJECT_NAME }}')].Endpoint.Address" --output text | head -1)
        fi
        RDS_PORT=$(aws rds describe-db-instances --db-instance-identifier "${{ env.PROJECT_NAME }}-db" --query "DBInstances[0].Endpoint.Port" --output text 2>/dev/null || echo "3306")
        RDS_HOST="${RDS_ENDPOINT}:${RDS_PORT}"
        echo "Found RDS endpoint: $RDS_HOST"
        
        # 3. Check ECR repository
        # We're already using a hardcoded repo name, so this is less critical
        ECR_REPOSITORY_NAME="${{ env.PROJECT_NAME }}-app-repository"
        echo "Using ECR repository: $ECR_REPOSITORY_NAME"
        
        # 4. Check ALB
        ALB_DNS_NAME=$(aws elbv2 describe-load-balancers --names "${{ env.PROJECT_NAME }}-alb" --query "LoadBalancers[0].DNSName" --output text 2>/dev/null)
        if [ "$ALB_DNS_NAME" == "None" ] || [ -z "$ALB_DNS_NAME" ]; then
          echo "Warning: Could not find ALB with name ${{ env.PROJECT_NAME }}-alb"
        fi
        APP_ALB_URL="http://${ALB_DNS_NAME}"
        echo "ALB DNS Name: $ALB_DNS_NAME"
        echo "ALB URL: $APP_ALB_URL"
        
        # Set outputs directly in GitHub's format
        echo "app_instance_id=$APP_INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "rds_endpoint=$RDS_HOST" >> $GITHUB_OUTPUT
        echo "ecr_repository_name=$ECR_REPOSITORY_NAME" >> $GITHUB_OUTPUT
        echo "alb_dns_name=$ALB_DNS_NAME" >> $GITHUB_OUTPUT
        echo "app_alb_url=$APP_ALB_URL" >> $GITHUB_OUTPUT

    - name: Verify Terraform Outputs
      run: |
        echo "Terraform outputs set for next job:"
        echo "APP_INSTANCE_ID = ${{ steps.terraform_outputs.outputs.app_instance_id }}"
        echo "RDS_ENDPOINT = ${{ steps.terraform_outputs.outputs.rds_endpoint }}"
        echo "ECR_REPOSITORY_NAME = ${{ steps.terraform_outputs.outputs.ecr_repository_name }}"
        echo "ALB_DNS_NAME = ${{ steps.terraform_outputs.outputs.alb_dns_name }}"
        echo "APP_ALB_URL = ${{ steps.terraform_outputs.outputs.app_alb_url }}"

  build-and-deploy:
    name: 'Build and Deploy Application'
    needs: terraform
    runs-on: ubuntu-latest
    # Always run this job when terraform completes, as the outputs issue should be fixed now

    env:
      APP_INSTANCE_ID: ${{ needs.terraform.outputs.app_instance_id }}
      RDS_HOST: ${{ needs.terraform.outputs.rds_endpoint }}
      ECR_REPOSITORY_NAME: ${{ needs.terraform.outputs.ecr_repository_name }}
      RDS_USER: admin
      RDS_PASSWORD: hrportaladmin123
      RDS_DATABASE: hrportal
      TF_STATE_BUCKET: ${{ needs.terraform.outputs.tf_state_bucket }}
      ALB_DNS_NAME: ${{ needs.terraform.outputs.alb_dns_name }}
      APP_ALB_URL: ${{ needs.terraform.outputs.app_alb_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Debug environment variables
      run: |
        echo "ECR Registry: ${{ steps.login-ecr.outputs.registry }}"
        echo "ECR Repository Name: ${{ env.ECR_REPOSITORY_NAME }}"
        if [ -z "${{ env.ECR_REPOSITORY_NAME }}" ]; then
          echo "::error::ECR_REPOSITORY_NAME is empty!"
          exit 1
        fi

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # Construct the full ECR repository URL using the registry from login step
        FULL_ECR_REPOSITORY="${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_NAME }}"
        echo "Full ECR Repository URL: ${FULL_ECR_REPOSITORY}"
        
        # Build a docker container and push it to ECR
        docker build -t ${FULL_ECR_REPOSITORY}:${{ github.sha }} .
        docker push ${FULL_ECR_REPOSITORY}:${{ github.sha }}
        docker tag ${FULL_ECR_REPOSITORY}:${{ github.sha }} ${FULL_ECR_REPOSITORY}:latest
        docker push ${FULL_ECR_REPOSITORY}:latest
        echo "image=${FULL_ECR_REPOSITORY}:${{ github.sha }}" >> $GITHUB_OUTPUT

    - name: Deploy to EC2 via SSM
      run: |
        # Verify we have the required values
        echo "Checking essential parameters:"
        echo "APP_INSTANCE_ID: ${{ env.APP_INSTANCE_ID }}"
        echo "RDS_HOST: ${{ env.RDS_HOST }}"
        
        # Exit if essential parameters are missing
        if [ -z "${{ env.APP_INSTANCE_ID }}" ]; then
          echo "::error::APP_INSTANCE_ID is empty! Cannot continue deployment."
          exit 1
        fi
        
        # Extract RDS hostname from endpoint if available
        DB_HOST=""
        if [ -n "${{ env.RDS_HOST }}" ]; then
          DB_HOST=$(echo "${{ env.RDS_HOST }}" | cut -d: -f1)
        fi
        
        # Wait for EC2 instance to be ready
        echo "Waiting for EC2 instance to be ready..."
        aws ec2 wait instance-status-ok --instance-ids ${{ env.APP_INSTANCE_ID }}
        
        # Deploy using SSM with multiple separate commands
        aws ssm send-command \
          --instance-ids ${{ env.APP_INSTANCE_ID }} \
          --document-name "AWS-RunShellScript" \
          --parameters commands=["docker stop hrportal || true",
                                "docker rm hrportal || true",
                                "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}",
                                "docker pull ${{ steps.build-image.outputs.image }}",
                                "docker run -d --name hrportal -p 3000:3000 -e DB_HOST=\"$DB_HOST\" -e DB_USER=\"${{ env.RDS_USER }}\" -e DB_PASSWORD=\"${{ env.RDS_PASSWORD }}\" -e DB_NAME=\"${{ env.RDS_DATABASE }}\" ${{ steps.build-image.outputs.image }}",
                                "docker ps | grep hrportal"] \
          --output text

    - name: Output Deployment Info
      run: |
        echo "Application deployed successfully!"
        
        if [ -n "${{ env.APP_ALB_URL }}" ]; then
          echo "Application Load Balancer URL: ${{ env.APP_ALB_URL }}"
        else
          echo "Application Load Balancer URL: Not available"
        fi
        
        if [ -n "${{ env.ALB_DNS_NAME }}" ]; then
          echo "Application Load Balancer DNS: ${{ env.ALB_DNS_NAME }}"
        else
          echo "Application Load Balancer DNS: Not available"
        fi
        
        EC2_IP=$(aws ec2 describe-instances --instance-ids ${{ env.APP_INSTANCE_ID }} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null)
        if [ -n "$EC2_IP" ] && [ "$EC2_IP" != "None" ]; then
          echo "Direct EC2 URL: http://$EC2_IP:3000"
        else
          echo "Direct EC2 URL: Not available"
        fi
        
        JENKINS_IP=$(aws ec2 describe-instances --filters 'Name=tag:Name,Values=${{ env.PROJECT_NAME }}-jenkins-instance' --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null)
        if [ -n "$JENKINS_IP" ] && [ "$JENKINS_IP" != "None" ]; then
          echo "Jenkins server should be accessible at: http://$JENKINS_IP:8080"
        else
          echo "Jenkins server: Not available or still starting up"
        fi
        
        echo "Terraform state is stored in S3 bucket: ${{ env.TF_STATE_BUCKET }}"
        echo "To destroy this infrastructure, use the Destroy Infrastructure workflow with this bucket name." 